{"meta":{"title":"hicode360","subtitle":"愿你出走半生 归来仍是少年","description":"关于java、python、搜索、大数据、推荐系统、NLP的工程和算法博客","author":"hicode360","url":"https://hicode360.github.io","root":"/"},"pages":[{"title":"about","date":"2021-09-27T09:02:54.000Z","updated":"2021-10-08T14:30:34.000Z","comments":true,"path":"about/index.html","permalink":"https://hicode360.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-09-27T08:54:47.000Z","updated":"2021-10-08T14:30:34.000Z","comments":true,"path":"categories/index.html","permalink":"https://hicode360.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-09-27T08:55:32.000Z","updated":"2021-10-08T14:30:34.000Z","comments":true,"path":"tags/index.html","permalink":"https://hicode360.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python中常用的数据类型","slug":"python/python中常用的数据类型","date":"2021-10-11T15:48:35.000Z","updated":"2021-10-11T15:50:26.000Z","comments":true,"path":"20211011/python/python中常用的数据类型/","link":"","permalink":"https://hicode360.github.io/20211011/python/python%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"可变数据类型对变量的值进行修改时，变量对应的内存地址不变，对应的值发生了改变，这种数据类型就称为可变数据类型。 不可变数据类型对变量的进行修改时，变量对应的内存地址发生了改变(变量指向了新的内存)，从而修改了变量的值，而变量对应的原内存的值并没有被改变，这种数据类型就称为可变数据类型。 也就是：不可变数据类型更改后地址发生改变，可变数据类型更改地址不发生改变 常用数据类型 数据类型 是否是可变数据类型 是否有序 None (空) 不可变 - int (整数) 不可变 - float (浮点) 不可变 - bool (布尔) 不可变 - str (字符串) 不可变 - tuple (元组) 不可变 序列类型，有序 list (列表) 可变 序列类型，有序 set (集合) 可变 序列类型，无序，不可重复 dict (字典) 可变 映射类型，v3.6及以后无有序, 前面版本无序 扩展 数据类型 是否是可变数据类型 是否有序 说明 bytes 不可变 - 定义字节：b’hello’,bytes(5) bytearray 可变 - 定义字节数组：bytearray(b’hello’), bytearray(10) complex (复数) 不可变 - 由一个实数和一个虚数组合构成，如：4+3j frozenset (冻结的set) 不可变 无序 冻结的set初始化后不能再添加或删除元素 array (数组) 可变 有序 数组中的元素必须是同一类型 OrderedDict 可变 有序 key有序，setdefault取值key不存在也不报错 defaultdict 可变 有序 取值时Key不存在也不会抛出KeyError异常 deque 可变 有序 高效插入和删除的双向队列列表 常见数据类型的操作和转换list列表[ ]list是**==可变==、==可重复==的==有序==**列表，里面的元素的数据类型也可以不同(也可以是另一个list)。list可根据索引号取其中的数据。 list的生成12345678list1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]print(&quot;list1: &quot;, list(list1)) # 输出： list1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]list2 = list(range(0, 10))print(&quot;list2: &quot;, list(list2))list3 = [i*i for i in range(10) if i % 2 == 0]print(&quot;list3: &quot;, list(list3))list4 = (str(i) + j for i in range(0, 10, 2) for j in &quot;xyz&quot;)print(&quot;list4: &quot;, list(list4)) list元素反转、排序和次数统计12345678910list1 = [0, 1, 2, 3, 4, 5, 5, 5, 6, 7, 8, 9]list1.reverse() # 元素顺序反转print(&quot;list reverse: &quot;, list1)list1.sort(reverse=False) # 排序print(&quot;list sort: &quot;, list1)list1 = sorted(list1, reverse=True)print(&quot;list sort: &quot;, list1)times = list1.count(5) # 查看list中的元素出现的次数print(&quot;times: &quot;, times) list元素的添加、删除和取值12345678910111213141516list1.append(10)print(&quot;append value: &quot;, list1) # 添加元素list1.insert(1, 10) # 在指定位置添加元素print(&quot;insert value: &quot;, list1)list1.remove(10) # 删除指定value元素(第一个匹配的元素)print(&quot;remove value: &quot;, list1)value = list1.pop(12) # 删除指定index的元素并返回删除的值list1.pop() # 不指定index时默认删除最后一个元素list1.pop(-2) # 删除倒数第二个元素print(&quot;remove index: &quot;, list1)index_value = list1.index(3) # 查找第一个value为100的index值，如果不存在报TypeError异常print(&quot;index_value: &quot;, index_value)print(list1)index_value = list1.index(5, 7, 9) # 指定范围，从第7(包括)个到第9(不包括)个元素之间查找value为5的indexprint(&quot;index_value: &quot;, index_value) list添加多个元素、list的合并12345list2 = [100, 101, 102]# list1 = list1 + list2list1.extend(list2)print(list1)print(&quot;*&quot; * 10) list的遍历1234567891011for value in list1: print(&quot;value: %i&quot; % value)print(&quot;*&quot; * 50)for index in range(len(list1)): print(&quot;index: %i, value: %i&quot; % (index, list1[index]))print(&quot;*&quot; * 50)for index, value in enumerate(list1): print(&quot;index: %i, value: %i&quot; % (index, value))print(&quot;*&quot; * 50)for index, value in enumerate(list1, 100): # index从100开始 print(&quot;index: %i, value: %i&quot; % (index, value)) list中使用切片(slice)取值12345678910111213elements = list1[0:3] # 取第0到3条元素(包括头不包括尾)# elements = list1[:3]print(&quot;slice elements: &quot;, elements)elements = list1[1:] # 取第1到最后一个元素(包括头也包括尾)print(&quot;slice elements: &quot;, elements)elements = list1[-2] # 取倒数第二条print(&quot;slice elements: &quot;, elements)elements = list1[4:-2] # 取第四条到倒数第二条(包括头不包括尾)print(&quot;slice elements: &quot;, elements)elements = list1[0:6:2] # 取第0条到第6条中每2个取一个print(&quot;slice elements: &quot;, elements)elements = list1[:] # 取所有元素print(&quot;slice elements: &quot;, elements) ==列表、元组和字符串==都可以使用切片进行操作 list的深copy和浅copy12345678910111213141516# 浅拷贝只拷贝了引用，没有拷贝内容list2 = list1list2[1] = 1000print(&quot;list1: &quot;, list1)print(&quot;list2: &quot;, list1)print(id(list1), id(list2))# 深拷贝是对于一个对象所有层次的拷贝(递归拷贝)list3 = list1.copy()# import copy# list3 = copy.copy(list1)# list3 = copy.deepcopy(list1)list1[1] = 1print(&quot;list1: &quot;, list1)print(&quot;list3: &quot;, list3)print(id(list1), id(list3)) set集合{ }set是**==可变==**、==不可重复==的==无序==列表。 ==set中不可以放入可变对象==，因为无法判断两个可变对象是否相等而去重。 set的定义123456789101112131415161718192021222324set0 = &#123;0, 0, 1, 2, 3, 4, 5, 4, 5, 6&#125; # 直接定义set集合print(&quot;set0: &quot;, set0) # 输出 set0: &#123;0,1, 2, 3, 4, 5, 6&#125;set1 = set([0, 0, 1, 2, 3, 4, 5, 4, 5, 6]) # 通过list定义setprint(&quot;set1: &quot;, set1)set2 = set((0, 0, 1, 2, 3, 4, 5, 4, 5, 6)) # 通过tuple定义setprint(&quot;set2: &quot;, set2)set3 = set(&#123;&quot;x&quot;: 2, 10: &quot;b&quot;&#125;) # 通过dict定义setprint(&quot;set3: &quot;, set3) # 输出 set3: &#123;10, &#x27;x&#x27;&#125;my_list = [0, 0, 1, 2, 3, 4, 5, 4, 5]set4 = set(my_list) # set中不可以放入可变对象,然而为何放入list却不报错?print(&quot;set4: &quot;, set4) # 输出 set4: &#123;0, 1, 2, 3, 4, 5, 6&#125;# 由下面操作可以得出结论,set是先把list做遍历得到不可变的int对象类型后再放入set中my_list[0] = 10print(&quot;set4 with my_list changed: &quot;, set4) # 输出 &#123;0, 1, 2, 3, 4, 5, 6&#125;my_list.append([10, 20])print(&quot;my_list: &quot;, my_list)set5 = set(my_list) # 在list再放入list,此时将报错print(&quot;set5: &quot;, set5) set元素的添加、删除和取值12345678910111213141516set0 = &#123;0, 0, 1, 2, 3, 4, 5, 4, 5, 6&#125;print(&quot;set0: &quot;, set0)set0.add(&quot;cn&quot;) # 添加单个元素print(&quot;set0: &quot;, set0)set0.update([10, 20, 30]) # 添加多个元素print(&quot;set0: &quot;, set0)set0.add((&quot;com&quot;, &quot;cn&quot;)) # 添加元组(元组是不可变数据类型)print(&quot;set0: &quot;, set0)# set0.add([10, 20]) # 添加list报错,不能添加可变的数据类型(不能添加,但可以使用list创建set)# set0.add(&#123;10, 20&#125;) # 添加set报错,(可是使用不可变的frozenset添加:set0.add(frozenset(&#123;10, 20&#125;)))# set0.add(&#123;&quot;x&quot;: 2, 10: &quot;b&quot;&#125;) # 添加dict报错,不能添加可变的数据类型(不能添加,但可以使用dict创建set)set0.remove(&quot;cn&quot;) # 根据值删除元素(set不能根据索引删除)print(&quot;set0: &quot;, set0) set取并集和交集12345set1 = &#123;&quot;a&quot;, &quot;b&quot;, 4, 6, 100&#125;my_set = set0 | set1 # 取并集print(my_set)my_set = set0 &amp; set1 # 取交集print(my_set) set遍历注：set的遍历同list dict字典{ }dict是**==无序==，key==不可重复==、==不可变==**内容以key-value键值对形式存在的映射 dict中的key只能是不可变对象且唯一, 一个key对应一个value，多次对一个key设置value，后面的值会把前面的冲掉。 dict一般用在需要高速查找的很多地方。dict的key必须是不可变对象，这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这种通过key计算位置的算法称为哈希算法（Hash）。要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list、set是可变的，所以就不能作为key。 dict的创建和增删改查12345678910111213141516dict1 = &#123;&quot;addr&quot;: &quot;北京&quot;, &quot;age&quot;: 18, &quot;gender&quot;: &quot;女&quot;&#125;dict1[&quot;height&quot;] = 1.77 # 添加元素dict1.pop(&quot;age&quot;) # 删除元素输出item_del = dict1.popitem() # 产出dict中的最后一个item并返回print(&quot;item_del: &quot;, item_del)dict1[&quot;addr&quot;] = &quot;深圳&quot; # 修改元素print(&quot;dict1: &quot;, dict1)keys = dict1.keys() # 获取dict的所有keyprint(&quot;keys: &quot;, keys) # dict_keys([&#x27;add&#x27;, &#x27;height&#x27;])addr = dict1.get(&quot;addr&quot;) # 根据key获取value,若key不存在报异常(defaultdict字典不报异常)print(&quot;addr: &quot;, addr)addr = dict1.setdefault(&quot;addr&quot;) # 根据key获取value,若key不存返回None,也可设置默认返回值print(&quot;addr: &quot;, addr)name = dict1.get(&quot;name&quot;, &quot;unknow&quot;) # 根据key获取value,若key不存返回默认值&#x27;unknow&#x27;print(&quot;name: &quot;, name) dict的遍历12345678910# dict的遍历for key in dict1: print(&quot;key: %s, value: %s&quot; % (key, dict1[key]))print(&quot;*&quot; * 50)for value in dict1.values(): print(&quot;value: &quot;, value)print(&quot;*&quot; * 50)for key, value in dict1.items(): print(&quot;key: %s, value: %s&quot; % (key, value)) dict的合并123dict2 = &#123;&quot;mobel&quot;: 15888888888, &quot;postal_code&quot;: 10000&#125; # 合并两个dictdict1.update(dict2)print(&quot;dict1: &quot;, dict1) dict和list的异同 list查找和插入的时间随着元素的增加而增加；占用空间小，浪费内存很少 dict查找和插入的速度极快，不会随着key的增加而变慢；需要占用大量的内存，内存浪费多。所以，dict是用空间来换取时间的一种方法。 dict的排序1234567891011121314151617181920212223# dict排序dict3 = &#123;&#x27;sh&#x27;: 3, &#x27;hz&#x27;: 2, &#x27;tj&#x27;: 1, &#x27;bj&#x27;: 5, &#x27;gz&#x27;: 2, &#x27;sz&#x27;: 4, &#x27;wh&#x27;: 1&#125;# 默认排序，并仅返回keykey_rank1 = sorted(dict3.keys(), reverse=False)print(&quot;key_rank1: &quot;, key_rank1)# 默认排序(以key来排序)，并返回key和valuedict_key_rank1 = sorted(dict3.items(), reverse=False)print(&quot;dict_key_rank1: &quot;, dict(dict_key_rank1))# 以key排序dict_key_rank2 = sorted(dict3.items(), key=lambda item: item[0], reverse=False)print(&quot;dict_key_rank2: &quot;, dict(dict_key_rank2))# 以value排序dict_value_rank1 = sorted(dict3.items(), key=lambda item: item[1], reverse=False)print(&quot;dict_value_rank1: &quot;, dict(dict_value_rank1))# 以value排序dict4 = &#123;&#x27;上海&#x27;: 3, &#x27;杭州&#x27;: 2, &#x27;天津&#x27;: 1, &#x27;北京&#x27;: 5, &#x27;广州&#x27;: 2, &#x27;深圳&#x27;: 4, &#x27;武汉&#x27;: 1&#125;dict_value_rank2 = sorted(dict4.items(), key=lambda item: item[1], reverse=True)print(&quot;dict_value_rank2: &quot;, dict(dict_value_rank2)) tuple元组( )tuple是**==不可变==、==有序==**的列表，所以一般在定义tuple时就进行初始化赋值。 注意： 在定义只有一个元素的tuple时其元素后面要加逗号 123tuple0 = () # 创建空元祖tuple0 = (1) # 不是tuple，会当成括号处理tuple0 = (1,) # 正确的tuple tuple虽然不可变但tuple中的元素对象却是可变的 12345my_list = [&quot;x&quot;, &quot;y&quot;]tuple1 = (&#x27;a&#x27;, &#x27;b&#x27;, my_list) # tuple包含list,list变化时,tuple1也就跟着变化print(&quot;tuple1: &quot;, tuple1) # tuple1: (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;x&#x27;, &#x27;y&#x27;])my_list.append(&quot;z&quot;)print(&quot;tuple1 with my_list changed: &quot;, tuple1) # tuple1变为(&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]) tuple的创建123tuple2 = (1, &quot;good&quot;, 2, 3, &quot;good&quot;, True) # 创建元组,里面的元素类型可以不同tuple3 = (&quot;a&quot;, &quot;b&quot;, *tuple2, 4, 5) # 元组引用另一个数组中的所有元素print(&quot;tuple3: &quot;, tuple3) tuple中元素的增删改查1234567891011element = tuple2[4] # 根据索引获取元组中的元素element = tuple2[-2] # 使用索引获取元组中的元素index = tuple2.index(&quot;good&quot;) # 获取第一个匹配给定值的index值del tuple2 # 删除元组# tuple2[4] = &quot;well&quot; # 修改元组的元素,报错tuple4 = (&quot;a&quot;, &quot;b&quot;, 4, 5, [6, 7, 8])print(&quot;tuple4: &quot;, tuple4)# tuple4[-1] = [10, 20, 30] #报错tuple4[-1][0] = 100 # 可以通过修改元组中的list,从而改变元组print(&quot;tuple4: &quot;, tuple4) # tuple4: (&#x27;a&#x27;, &#x27;b&#x27;, 4, 5, [100, 7, 8]) tuple的遍历注：tuple的遍历同list","categories":[{"name":"python","slug":"python","permalink":"https://hicode360.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hicode360.github.io/tags/python/"},{"name":"数据类型","slug":"数据类型","permalink":"https://hicode360.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"git常用命令","slug":"git/git常用命令","date":"2021-09-28T03:05:35.000Z","updated":"2021-10-08T14:30:34.000Z","comments":true,"path":"20210928/git/git常用命令/","link":"","permalink":"https://hicode360.github.io/20210928/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"git常用命令123456789101112131415161718192021222324252627282930git clone https://github.com/username/project.github.io.git #拉取代码(master/main)git clone -b _dev https://github.com/username/project.github.io.git #拉取分支(非master或main分支)git checkout --track origin/_remote #获取指定的远程分支到本地git branch #查看本地分支git branch -a #查看远程分支git branch -vv#查看分支的绑定信息git branch _local #创建本地分支git branch -d _local #删除本地分支(当前分支不能停留在要删除的分支上)git checkout _local #切换到本地分支git checkout -b _local # 创建并切换到本地创建的分支git push --set-upstream origin _remote #创建远程分支git branch -r -d origin/_remote #删除远程分支(记得push一下 git push origin _remote)git checkout -b _local origin/_remote #创建本地分支绑定远程分支git status #查看修改过代码的类git diff #查看修改的代码git add src/main/java/com/so/alg/RecommendServiceImpl.java #添加修改的代码git commit -m &quot;recommend feed modified&quot; #给修改的代码添加注释git pull origin _remote #从远程更新变动的代码git push origin _local:_remote #提交git merge _remote #合并分支到master上(需要先切换到master分支上,在执行合并)git tag -a 2020071801 -m &#x27;v2.0部署&#x27; #添加taggit show 2020071801 #展示taggit push --tags #提交tag git配置SSH公钥和私钥1234567891011121314151617# 1.生成公钥和私钥(邮箱为github注册邮箱)ssh-keygen -t rsa -C &quot;xxxxxx@gmail.com&quot;# 2.设置公钥私钥key的保存位置(可以直接确认则保存在默认位置)Generating public/private rsa key pair.Enter file in which to save the key (/Users/username/.ssh/id_rsa):# 3.输入、重复输入密钥盐值Enter passphrase (empty for no passphrase):Enter same passphrase again:# 4.复制打印的公钥内容，并在github-&gt;Settings-&gt;SSH and GPG keys-&gt;New SSH Key中设置(title随意起)cat .ssh\\id_rsa.pub# 5.查看密钥是否配置成功(会提示输入盐值)ssh -T git@github.comEnter passphrase for key &#x27;/Users/username/.ssh/id_rsa&#x27;:Hi hicode360! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.# 6.配置全局git信息git config --global user.name &quot;username&quot; # github用户名git config --global user.email &quot;xxxxxx@gmail.com&quot; #github注册邮箱","categories":[{"name":"git","slug":"git","permalink":"https://hicode360.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hicode360.github.io/tags/git/"},{"name":"命令","slug":"命令","permalink":"https://hicode360.github.io/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"linux文件压缩、解压、打包、解包命令总结","slug":"linux/linux文件压缩、解压、打包、解包命令","date":"2021-09-27T10:26:29.000Z","updated":"2021-10-08T14:30:34.000Z","comments":true,"path":"20210927/linux/linux文件压缩、解压、打包、解包命令/","link":"","permalink":"https://hicode360.github.io/20210927/linux/linux%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E3%80%81%E8%A7%A3%E5%8E%8B%E3%80%81%E6%89%93%E5%8C%85%E3%80%81%E8%A7%A3%E5%8C%85%E5%91%BD%E4%BB%A4/","excerpt":"","text":"文件压缩、解压、打包、解包zip压缩/unzip解压zip/unzip [参数] 被压缩文件 参数： 参数 含义 -r 压缩所有子目录 -d 解压 命令 # 压缩成zip文件(其中havorld.zip中的.zip可以省略，默认扩展名为zip) zip -r havorld.zip ./havorld/* # 解压zip文件到指定目录 unzip -d /home/havorld havorld.zip 注：zip既能压缩文件又能压缩目录 gzip压缩/解压gzip使用格式： gzip [参数] 被压缩文件 参数： 参数 含义 -r 压缩所有子目录 -d 解压 命令 gzip havorld.txt # 压缩指定文件 ,生成havorld.txt.tar.gz gzip -r havorld.tar havorld.tar.gz # 压缩文件 gzip havorld.tar # 压缩打包文件，生成havorld.tar.gz gzip -d havorld.tar.gz # 解压文件 注：gzip只能压缩文件不能压缩目录 打包(归档)/解包 tar 数据备份：把一系列文件打包到一个大文件中 恢复数据：把档案文件数据解包 tar使用格式： tar [参数] 打包文件名 文件 参数： 参数 含义 -c 生成档案文件，创建打包文件 -v 列出打包解档的详细过程，显示进度 -f 指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后 -t 列出档案中包含的文件 -x 解开档案文件 注：参数前面的 “-“ 也加可不加 命令： # 打包指定文件,生成.tar文件 tar -cvf havorld.tar havorld.txt meng.log # 打包文件havorld目录下的所有文件,生成.tar文件 tar -cvf havorld.tar ./havorld* # 解包.tar的文件 tar -xvf havorld.tar 注：tar只负责打包文件但不压缩，在tar命令中增加一个参数(-z)调用gzip实现打包+压缩的功能，其扩展名一般为.tar.gz # 打包+压缩指定文件,生成.tar.gz文件 tar -cvzf havorld.tar.gz havorld.txt meng.log # 打包+压缩havorld目录下的所有文件,生成.tar.gz文件 tar -cvzf havorld.tar.gz ./havorld* # 解压缩+解包.tar.gz的文件到指定目录 tar -zxvf havorld.tar.gz -C /home/havorld bzip2压缩/bunzip2解压由于 bzip2 与 gzip 相比，其压缩稳定性和效果都更好，用法跟gzip一样 bzip2 havorld.txt # 生成havorld.txt.bz2 bzip2 -k havorld.txt # 生成havorld.txt.bz2，并保留源文件 bunzip2 havorld.txt # 生成havorld.txt.bz2 bunzip2 -k havorld.txt # 生成havorld.txt.bz2，并保留源文件 tar与bzip2命令结合使用实现文件打包和压缩，其扩展名一般用xxxx.tar.gz2。 在tar命令中增加一个选项(-j)可以调用bzip2实现了一个压缩的功能，实行一个先打包后压缩的过程。 # 打包+压缩指定文件,生成.tar.gz文件 tar -jcvf havorld.tar.bz2 havorld.txt meng.log # 打包+压缩havorld目录下的所有文件,生成.tar.gz文件 tar -jcvf havorld.tar.bz2 ./havorld* # 解压缩+解包.tar.gz的文件到指定目录 tar -jxvf havorld.tar.bz2 -C /home/havorld","categories":[{"name":"linux","slug":"linux","permalink":"https://hicode360.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hicode360.github.io/tags/linux/"},{"name":"文件压缩","slug":"文件压缩","permalink":"https://hicode360.github.io/tags/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/"},{"name":"文件解压","slug":"文件解压","permalink":"https://hicode360.github.io/tags/%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://hicode360.github.io/categories/python/"},{"name":"git","slug":"git","permalink":"https://hicode360.github.io/categories/git/"},{"name":"linux","slug":"linux","permalink":"https://hicode360.github.io/categories/linux/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hicode360.github.io/tags/python/"},{"name":"数据类型","slug":"数据类型","permalink":"https://hicode360.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"git","slug":"git","permalink":"https://hicode360.github.io/tags/git/"},{"name":"命令","slug":"命令","permalink":"https://hicode360.github.io/tags/%E5%91%BD%E4%BB%A4/"},{"name":"linux","slug":"linux","permalink":"https://hicode360.github.io/tags/linux/"},{"name":"文件压缩","slug":"文件压缩","permalink":"https://hicode360.github.io/tags/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/"},{"name":"文件解压","slug":"文件解压","permalink":"https://hicode360.github.io/tags/%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B/"}]}